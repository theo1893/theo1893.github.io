---
title: Redis源码图解(20) Redis AOF重写基本原理
date: 2024-10-09 22:15:54
categories:
- Tech
tags:
- redis
---

# Redis AOF重写

Redis AOF重写可以被分为2个部分: 触发重写, 重写流程. 下面先介绍重写的流程, 再介绍Redis在什么情况下会触发AOF重写.

## Redis AOF重写流程

下图给出Redis AOF重写的大致流程.

![](aof_rewrite_process.png)

这里我们可以看到一个有趣的地方: 当Redis fork出子进程后, 父进程和子进程的Dict Rehash策略都被收紧了: 子进程的策略为FORBID, 不被允许进行rehash; 父进程的策略为AVOID, 尽量避免rehash. 这种变更是为了尽可能少地触发写时拷贝, 减少开销.

具体地, 对父进程而言:

如果当前已经进入扩容阶段, 只有负载因子已经 > 4 才允许进行**实际的rehash操作**; 而在策略收紧之前, 负载因子到达1就可以进入扩容阶段.

如果当前已经进入缩容阶段, 只有负载因子 < 1/32, 才允许进行**实际的rehash操作**; 而在策略收紧之前, 负载因子到达1/8就可以进入缩容阶段.

### 重写操作

具体的重写操作由子进程执行, 大致流程如下图.

![](aof_rewrite_op.png)

AOF重写的本质是, 找到能够描述当前全部数据的最优指令列表. 显而易见, 最优的指令必然是假设每条数据都是通过插入的方式到达当前状态. 因此重写操作的流程就是: **遍历当前的所有数据, 将其转换成插入数据的指令**. 

如上图所示, 首先写入SELECT指令, 然后写入某个key的插入指令, 最后写入PEXPIREAT指定这个key的过期时间.

### 根据不同类型写入指令

在上图中我们知道, 重写流程的本质是将当前数据分布翻译成插入新数据的指令, 因此不同类型的key对应的重写指令不同.

以List为例, 对List类型的k1重写流程如下:

S1. 初始化k1的迭代器, 从队列头开始;

S2. 遍历k1中的每一个元素, 每**64**个值打一次包向AOF文件写入RPUSH指令的RESP表达, 以减少总的指令数.
		RPUSH k1 value1 value2 value3 value4 ...... value64
		RPUSH k1 value65 ...... value128

S3. 退出

大致流程如下图所示:

![](rewrite_list.png)

对其他类型而言流程基本一致, 不过多描述.

在全部重写完成后, 子进程将AOF Rewrite文件写入磁盘, 正常退出.

## AOF重写触发时机

主要有2个:

1. 手动执行BGREWRITEAOF指令.
2. 当前AOF文件增长已经超过100%, 触发AOF重写.

第1个触发点发生在用户输入; 第2个触发点发生在服务器定时任务(前文提到的每1ms执行一次的任务)中, 判断如下图所示.

![](aof_rewrite_cron_trigger.png)



#### 上文提到的Dict Rehash策略什么时候恢复?

仍然在Redis Server每1ms执行一次的定时任务中. 

主线程(即主进程)会扫描当前子进程的状态, 如果子进程已经完成了, 主线程的Dict Rehash策略就会恢复到正常水平.

