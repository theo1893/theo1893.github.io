---
title: Redis源码图解(16) 我们在客户端使用SET命令, 直到服务端返回, 发生了什么(单机)
date: 2024-08-19 16:34:21
categories:
- Tech
tags:
- redis

---

# 一条SET指令的处理流程

本节介绍**单机模式**下, 开启**多线程写**和**多线程读**时, 一条SET NX指令的主要处理流程.

有部分个人认为对理解Redis核心逻辑无益的流程不会介绍.

## 建立TCP连接

第一步, 客户端向服务端发起连接建立的请求.

在前面的章节中, 我们知道服务端在启动后, 会注册socket监听事件, 并进入AE事件循环, 如下图所示.

![](event_loop.png)

在收到客户端建立连接的请求后, 服务端的监听socket变为可读, AE事件总线在一次查询内核的过程中, 得知监听socket可读, 便进入此事件的处理流程: 

1. 创建新的TCP连接;
2. 为这些连接分别注册AE监听事件;

具体的流程如下图所示, AE总线在本次循环结束后新注册了1个文件事件.

![](event_loop_accept_connection.png)

## RESP(REdis Serialization Protocol)协议

Redis基于TCP实现了RESP协议, 用于客户端和服务端之间的通信.

我们在客户端输入以下指令:

```shell
SET k1 v1 NX EX 3
```

客户端会将这条指令转换为如下的字节流:

![](resp_set_byte.png)

客户端然后将这组字节写入建立的连接中.

## Redis处理客户端请求

在某次事件循环中, Redis从内核得知上文建立的socket变为可读, 调用其注册的读方法.

由于开启了多线程读, **本次请求会被缓存到延迟读队列**, 不会发生实际的读取操作.

大致流程如下.

![](event_loop_epoch_1.png)

## Redis进入下一轮事件循环

Redis在进入下一轮事件循环后, 首先调用beforesleep()方法, 处理被延迟的读连接和写连接.

### 多线程处理延迟读

在此时, Redis将前文的连接分发给主线程和子线程, 进行实际的读取操作: 

解析RESP协议格式的字节流, 将解析结果保存在连接对象中.

这里需要注意的是, 在此阶段Redis主线程并不会进行指令处理.

### 主线程处理指令

等待所有线程完成读操作后, 主线程开始顺序处理每个连接的指令.

#### 查询指令表(Command Table)

在Redis初始化章节, 我们介绍过Redis维护了一张指令表, 此时在处理客户端请求时会在指令表中查询SET对应的入口函数.

#### 将Key-Value写入数据存储

在Dict的章节中, 我们介绍过Redis的DB结构实际使用的就是Dict. 在SET对应的函数中, 指定的key-value会被写入Redis的数据存储, 写入流程参考Dict的插入流程.

#### 将Key-Expiry写入过期存储

除了数据存储, Redis还维护了一份过期存储, 同样采用Dict结构, 存储了每个Key和对应的Expiry.

在这个场景下, 我们为k1指定了3s的过期时间, 因此expiry = 当前时间+3s 会被存储在过期存储中.

#### 回复给客户端

此时操作全部完成, 由于开启了多线程写, Redis将此连接放到**延迟写队列**, 此时不进行实际的写操作.

#### 多线程处理延迟写

在此时, 由于开启了多线程写, Redis会把前文主线程处理完成后等待写入的连接, 从延迟写队列拿出来, 分发给主线程和子线程, 将返回写入socket.

## 全流程示意图

串联上述步骤的图示如下.

![](process_command.png)

