<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Theo's Pub</title><meta name="author" content="Theo"><meta name="copyright" content="Theo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="This is nil.">
<meta property="og:type" content="website">
<meta property="og:title" content="Theo&#39;s Pub">
<meta property="og:url" content="https://theo1893.github.io/page/2/index.html">
<meta property="og:site_name" content="Theo&#39;s Pub">
<meta property="og:description" content="This is nil.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:author" content="Theo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://theo1893.github.io/page/2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Theo\'s Pub',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-08-23 16:04:28'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Theo's Pub"><span class="site-name">Theo's Pub</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">Theo's Pub</h1></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/08/12/IntSet/" title="Redis源码图解(7) 底层编码IntSet">Redis源码图解(7) 底层编码IntSet</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-08-12T07:58:48.000Z" title="发表于 2024-08-12 15:58:48">2024-08-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Tech/">Tech</a></span></div><div class="content">IntSetIntSet是Set类型的可选编码, 其结构由数据编码、数据数量、数据存储3个部分组成, 等价于有序数组, 定义如下.
1234567891011typedef struct intset &#123;    /*      数据编码, 可选:      INTSET_ENC_INT16      INTSET_ENC_INT32      INTSET_ENC_INT64    */    uint32_t encoding;        uint32_t length;      // 数据数量    int8_t contents[];    // 数据存储&#125; intset;

内存模型如下.

IntSet插入数据由于IntSet可以用来存储任意类型的整型数据, 在当前编码位数不足以表示新数据时, 会出现编码升级的行为.
涉及编码升级的新数据插入流程如下图所示. 值得一提的是, IntSet的编码并没有降级的流程.

在不涉及编码升级时, 额外增加了二分查找定位的过程, 如下图所示.

IntSet删除数据删除数据由二分查找定位, 迁移数据和释放内存3个 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/08/10/ListPackEx/" title="Redis源码图解(6) 底层编码ListPackEx">Redis源码图解(6) 底层编码ListPackEx</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-08-10T09:15:14.000Z" title="发表于 2024-08-10 17:15:14">2024-08-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Tech/">Tech</a></span></div><div class="content">ListPackExListPackEx是在ListPack基础上增加元数据后得到的新编码, 但和ListPack的所处层级不同, 虽然在实现上是底层编码, 但从逻辑上而言, 实际上高于底层编码, 低于高层类型. 当前ListPackEx仅被用来支持Hash的过期机制.
在实现上, ListPackEx由3个部分组成: 过期相关的元数据, Hash表Key, 指向ListPack的指针.
在ListPackEx的使用场景中, 其指向的ListPack中必然是每3个元素成组地出现.
ListPackEx的内存模型如下, 每个三元组中, 第1个是key, 第2个是value, 第3个是这组k-v设置的过期时间.

ListPackEx插入数据向ListPackEx插入新数据分为2种情况:

插入数据永不过期;
插入数据存在过期时间;

针对情况1, 新数据永远会追加在ListPackEx的队列尾部.
针对情况2, 新数据会被插入到第一个晚于自身过期时间的元素之前, 即队列按照过期时间升序增长.
下图展示了向队列中插入带过期时间数据的流程.

ListPackEx删除数据删除逻辑和ListP ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/08/10/QuickList/" title="Redis源码图解(5) 底层编码QuickList">Redis源码图解(5) 底层编码QuickList</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-08-10T06:59:40.000Z" title="发表于 2024-08-10 14:59:40">2024-08-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Tech/">Tech</a></span></div><div class="content">QuickListQuickList是redis中List类型的可选编码, 比ListPack更高层, 涉及到多个结构体定义.
QuickList是由quicklistNode构成的双向链表, 包含指向表头和表尾的指针, 节点内的数据存储可能为下面两种类型:

ListPack, 在未压缩的节点中使用;
原始数据, 在未压缩的节点中使用, 可以等价为char[];
quicklistLZF, 在压缩节点中使用;

ListPack的定义在上一节已经给出, 因此在此略过, 其他相关结构体定义如下. :
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// QuickList结构typedef struct quicklist &#123;    quicklistNode *head;    quicklistNode *tail;    unsigned long count;                  // 内部包含的总有效数据个数: 1个 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/08/09/ListPack/" title="Redis源码图解(4) 底层编码ListPack">Redis源码图解(4) 底层编码ListPack</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-08-09T08:40:20.000Z" title="发表于 2024-08-09 16:40:20">2024-08-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Tech/">Tech</a></span></div><div class="content">ListPackListPack是redis中List类型的可选编码, 用在数据量较小的List上.
ListPack由3个部分组成:

Header, 记录ListPack的Entry数和总字节数;

Entry, 是ListPack的数据单元, 由编码后的数据(变长)和当前数据的字节数(变长, 最大为5Byte)组成, 其中记录当前数据的字节数是为了支持ListPack从尾部向头部的遍历(起到记录偏移量的作用);

EOF, 标记ListPack的结束;


ListPack没有在代码中的结构体定义, 通过宏和内存函数直接操作内存, 其等价内存模型如下图所示:

ListPack插入数据在了解ListPack的内存模型后, 向ListPack写入数据的流程就变得非常清晰, 主要分为以下步骤:

将原始数据编码为Entry;
重新分配内存;
将旧数据拷贝道新的内存中;
将Entry写入新的内存指定偏移位置;
更新ListPack头;

图示如下:

ListPack删除数据和插入类似, 删除操作也分为以下步骤:

解码Entry的总字节数;

重新分配内存;

将旧数据拷贝到新的内存 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/08/08/Dict/" title="Redis源码图解(3) 底层编码HT(Dict)">Redis源码图解(3) 底层编码HT(Dict)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-08-08T05:28:37.000Z" title="发表于 2024-08-08 13:28:37">2024-08-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Tech/">Tech</a></span></div><div class="content">DictDict是redis中最底层的哈希结构, 是Redis DB、Expire DB等结构的数据存储部分, 也是Hash, Set, ZSet等类型的可选数据编码. 其定义如下:
1234567891011121314151617181920212223struct dict &#123;    dictType *type;               // 函数指针集合, 保存dict用来比较key、计算hash等操作的函数    dictEntry **ht_table[2];      // 2个table, 其中1个用于当前使用，另一个用于rehash    unsigned long ht_used[2];     // 记录对应table中存储的数据的数量    long rehashidx;               // 记录rehash的bucket, 如果==-1, 则未处于rehash    unsigned pauserehash : 15;     unsigned useStoredKeyApi : 1;     signed char ht_siz ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/08/06/SDS/" title="Redis源码图解(2) 底层编码SDS">Redis源码图解(2) 底层编码SDS</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-08-06T08:43:10.000Z" title="发表于 2024-08-06 16:43:10">2024-08-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Tech/">Tech</a></span></div><div class="content">SDS(Simple Dynamic String)SDS是redis中所有字符型数据的底层存储结构, 包含3个header字段和实际的数据存储:
12345678910111213141516171819202122232425262728// 以sdshdr8举例; 不同的hdr区别仅在于名字和len, alloc的数据类型struct __attribute__ ((__packed)) sdshdr8 &#123;    uint8_t len;			// 当前已使用字节数    uint8_t alloc;			// 当前分配空间    unsigned char flags;	// 记录sds的类型: SDS_TYPE_8, SDS_TYPE_16...    char buf[];				// 字符数据存储&#125;struct __attribute__ ((__packed)) sdshdr16 &#123;    uint16_t len;			    uint16_t alloc;			    unsigned char flags;	    char buf[ ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/08/05/RedisObject/" title="Redis源码图解(1) RedisObject">Redis源码图解(1) RedisObject</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-08-05T05:54:39.000Z" title="发表于 2024-08-05 13:54:39">2024-08-05</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Tech/">Tech</a></span></div><div class="content">Redis ObjectRedis Object是redis对外提供的最基础的数据类型, 对用户而言, 能够直接接触到的对象全部是Redis Object类型.
1234567891011121314151617181920212223242526272829typedef struct redisObject &#123;    unsigned type:4;		// 数据类型    unsigned encoding:4;	// 数据编码    unsigned lru:LRU_BITS;	// 最后一次使用时间戳，和过期机制相关    int refcount;			// 引用数    void *ptr;				// 指向底层数据的指针&#125; robj;// 对常见顶层类型而言, type的枚举如下#define OBJ_STRING 0    #define OBJ_LIST 1      #define OBJ_SET 2       #define OBJ_ZSET 3      #define OBJ_HASH 4      // 类型的编码encoding枚举 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/06/17/timerCtx/" title="timerCtx">timerCtx</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-06-17T11:31:27.000Z" title="发表于 2024-06-17 19:31:27">2024-06-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Tech/">Tech</a></span></div><div class="content">timerCtxtimerCtx是cancelCtx的一种封装, 在cancelCtx提供的手动cancel基础上, 额外提供了定时触发cancel的功能.
其结构定义如下:
123456789type timerCtx struct &#123;    // parent context, 这里是cancelCtx    cancelCtx    // 计时器    timer *time.Timer        // cancel时间    deadline time.Time&#125;

入口函数一般使用context.WithDeadline获取timerCtx.
12345678910111213141516171819202122232425262728293031323334353637// 一般使用此方法func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) &#123;    return WithDeadlineCause(parent, d, nil)&#125;func Wit ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/06/17/cancelCtx/" title="cancelCtx">cancelCtx</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-06-17T11:31:22.000Z" title="发表于 2024-06-17 19:31:22">2024-06-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Tech/">Tech</a></span></div><div class="content">cancelCtxcancelCtx通过实现canceler接口, 提供了取消context的能力. 其结构体定义如下:
12345678910111213141516171819type cancelCtx &#123;    // parent context    Context        // 锁, 用于并发场场景下保护其他变量    mu			sync.mutex    // 存储chan struct&#123;&#125;    done		atomic.Value    // 存储此context的子context    children	map[canceler]struct&#123;&#125;    err 		error    cause		error&#125;type canceler interface &#123;    // 实际cancel context的方法    cancel(removeFromParent bool, err, cause error)    Done() &lt;-chan struct&#123;&#125;&#1 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/06/17/valueCtx/" title="valueCtx">valueCtx</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-06-17T11:31:18.000Z" title="发表于 2024-06-17 19:31:18">2024-06-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Tech/">Tech</a></span></div><div class="content">valueCtx用于存储数据的context, 其定义如下:
123456type valueCtx struct &#123;    // parent context    Context    // 存储的key-value    key, val interface&#123;&#125;&#125;

入口函数使用context.WithValue获取valueCtx.
12345func WithValue(parent Context, key, val any) Context &#123;    ...    // 创建新的valueCtx, 记录parent context, 构成一种链式结构    return &amp;valueCtx(parent, key, val)&#125;

内存结构:
Value()valueCtx通过重写Value方法, 提供了数据查询的能力: 查询指定key对应的value, 如果自身不负责指定key的存储, 便向上递归查询.
123456789101112131415161718192021222324252627282930 ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Theo</div><div class="author-info__description">This is nil.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/21/HowDoesGETWorks/" title="Redis源码图解(17) 我们在客户端使用GET命令, 直到服务端返回, 发生了什么(单机)">Redis源码图解(17) 我们在客户端使用GET命令, 直到服务端返回, 发生了什么(单机)</a><time datetime="2024-08-21T08:02:59.000Z" title="发表于 2024-08-21 16:02:59">2024-08-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/19/HowDoesSETNXWorks/" title="Redis源码图解(16) 我们在客户端使用SET命令, 直到服务端返回, 发生了什么(单机)">Redis源码图解(16) 我们在客户端使用SET命令, 直到服务端返回, 发生了什么(单机)</a><time datetime="2024-08-19T08:34:21.000Z" title="发表于 2024-08-19 16:34:21">2024-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/19/WhatDoesRedisDoWhenStarting/" title="Redis源码图解(15) Redis服务端在启动时做了什么(单机)">Redis源码图解(15) Redis服务端在启动时做了什么(单机)</a><time datetime="2024-08-19T06:22:01.000Z" title="发表于 2024-08-19 14:22:01">2024-08-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/18/RedisAEEvent/" title="Redis源码图解(14) Redis 多路复用机制——AE事件模型">Redis源码图解(14) Redis 多路复用机制——AE事件模型</a><time datetime="2024-08-18T08:52:12.000Z" title="发表于 2024-08-18 16:52:12">2024-08-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/17/ZSet/" title="Redis源码图解(13) 高级类型ZSet">Redis源码图解(13) 高级类型ZSet</a><time datetime="2024-08-17T05:06:39.000Z" title="发表于 2024-08-17 13:06:39">2024-08-17</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Tech/"><span class="card-category-list-name">Tech</span><span class="card-category-list-count">21</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/redis/" style="font-size: 1.5em; color: #99a9bf">redis</a> <a href="/tags/context/" style="font-size: 1.1em; color: #999">context</a> <a href="/tags/golang/" style="font-size: 1.1em; color: #999">golang</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><span class="card-archive-list-count">17</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><span class="card-archive-list-count">4</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">21</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-08-23T08:04:27.940Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Theo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>